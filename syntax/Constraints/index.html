<!DOCTYPE html><head><meta charset="UTF-8"><title>Constraints System | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://hugary1995.github.io/raccoon/index.html" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="448e6fba-d9ef-4e81-b514-f896f6fd4107" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="06829c21-6920-4519-809b-637656da7e37" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a1719891-1693-4941-8632-31c38de91289" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9f74e04a-9948-4e0e-a75c-138d98476855" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="b9ef1193-5f81-49b5-b110-07db5bbb6fdd"><i class="material-icons">menu</i></a><ul class="sidenav" id="b9ef1193-5f81-49b5-b110-07db5bbb6fdd"><li><a href="#!" class="dropdown-trigger" data-target="a5a1854f-010c-4779-a432-af05e0e07497" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="59a5fad9-e109-4ba4-99bd-ed1aa23daf0b" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c76737f9-1f19-4eb3-9beb-3a8163db75ff" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="43af6291-fb6f-4133-904f-193fd592f760" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="448e6fba-d9ef-4e81-b514-f896f6fd4107"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li></ul><ul class="dropdown-content" id="06829c21-6920-4519-809b-637656da7e37"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_soil_desiccation.html">4. Soil desiccation</a></li><li><a href="../../tutorials/05_large_deformation_elasticity.html">5. Large deformation</a></li><li><a href="../../tutorials/06_elastoplasticity.html">6. Elastoplasticity</a></li><li><a href="../../tutorials/07_ductile_fracture.html">7. Ductile fracture</a></li><li><a href="../../tutorials/08_three_point_bending.html">8. Three-point bending</a></li></ul><ul class="dropdown-content" id="a1719891-1693-4941-8632-31c38de91289"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="9f74e04a-9948-4e0e-a75c-138d98476855"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../tensor_mechanics.html">Tensor mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_conduction.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="a5a1854f-010c-4779-a432-af05e0e07497"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li></ul><ul class="dropdown-content" id="59a5fad9-e109-4ba4-99bd-ed1aa23daf0b"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_soil_desiccation.html">4. Soil desiccation</a></li><li><a href="../../tutorials/05_large_deformation_elasticity.html">5. Large deformation</a></li><li><a href="../../tutorials/06_elastoplasticity.html">6. Elastoplasticity</a></li><li><a href="../../tutorials/07_ductile_fracture.html">7. Ductile fracture</a></li><li><a href="../../tutorials/08_three_point_bending.html">8. Three-point bending</a></li></ul><ul class="dropdown-content" id="c76737f9-1f19-4eb3-9beb-3a8163db75ff"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="43af6291-fb6f-4133-904f-193fd592f760"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../tensor_mechanics.html">Tensor mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_conduction.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://hugary1995.github.io/raccoon/index.html" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="3bb8e78b-4740-479c-a1fe-83924959d3bc" data-section-level="1" data-section-text="Constraints System"><h1 id="constraints-system">Constraints System</h1><section id="b74ca505-62f6-40d1-845a-7191f2878e3e" data-section-level="2" data-section-text="MortarConstraints"><h2 id="mortarconstraints">MortarConstraints</h2><section id="4bdca475-b07b-496d-b18f-e02b30c02d16" data-section-level="3" data-section-text="Overview"><h3 id="overview">Overview</h3><p>An excellent overview of the conservative mortar constraint implementation in MOOSE is given in <a href="#osti_1468630">Peterson (2018)</a>. We have verified that the MOOSE mortar implementation satisfies <em>a priori</em> error estimates (see discussion and plots on <a href="https://github.com/idaholab/moose/issues/13080">this github issue</a>):</p><div form="['center', 'center', 'center', 'center']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:center">Primal FE Type</th><th style=";text-align:center">Lagrange Multiplier (LM) FE Type</th><th style=";text-align:center">Primal L2 Convergence Rate</th><th style=";text-align:center">LM L2 Convergence Rate</th></tr></thead><tbody><tr><td style=";text-align:center">Second order Lagrange</td><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">3</td><td style=";text-align:center">2.5</td></tr></tbody><tbody><tr><td style=";text-align:center">Second order Lagrange</td><td style=";text-align:center">Constant monomial</td><td style=";text-align:center">3</td><td style=";text-align:center">1</td></tr></tbody><tbody><tr><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">2</td><td style=";text-align:center">1.5</td></tr></tbody><tbody><tr><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">Constant monomial</td><td style=";text-align:center">2</td><td style=";text-align:center">1.5</td></tr></tbody></table></div></section><section id="f20539d3-c5c3-4155-bc88-83fd62ca353a" data-section-level="3" data-section-text="Parameters"><h3 id="parameters">Parameters</h3><p>There are four required parameters the user will always have to supply for a constraint derived from <code>MortarConstraint</code>:</p><ul class="browser-default"><li><p><code>primary_boundary</code>: the boundary name or ID assigned to the primary side of the mortar interface </p></li><li><p><code>secondary_boundary</code>: the boundary name or ID assigned to the secondary side of the mortar interface </p></li><li><p><code>primary_subdomain</code>: the subdomain name or ID assigned to the lower-dimesional block on the primary side of the mortar interface </p></li><li><p><code>secondary_boundary</code>: the subdomain name or ID assigned to the lower-dimensional block on the secondary side of the mortar interface</p></li></ul><p>As suggested by the above required parameters, the user must do some mesh work before they can use a <code>MortarConstraint</code> object. The easiest way to prepare the mesh is to assign boundary IDs to the secondary and primary sides of the interface when creating the mesh in their 3rd-party meshing software (e.g. Cubit or Gmsh). If these boundary IDs exist, then the lower dimensional blocks can be generated automatically using the <code>LowerDBlockFromSidesetGenerator</code> mesh generator as shown in the below input file snippet:</p><pre class="moose-pre"><code class="language-text">
[Mesh]
  [./primary]
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;2&#x27;
    new_block_id = &#x27;20&#x27;
  [../]
  [./secondary]
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;1&#x27;
    new_block_id = &#x27;10&#x27;
  [../]
[]
</code></pre><p>There are also some optional parameters that can be supplied to <code>MortarConstraints</code>. They are:</p><ul class="browser-default"><li><p><code>variable</code>: Corresponds to a Lagrange Multipler variable that lives on the lower dimensional block on the secondary face </p></li><li><p><code>secondary_variable</code>: Primal variable on the secondary side of the mortar interface (lives on the interior elements) </p></li><li><p><code>primary_variable</code>: Primal variable on the primary side of the mortar interface (lives on the interior elements). Most often <code>secondary_variable</code> and <code>primary_variable</code> will correspond to the same variable </p></li><li><p><code>compute_lm_residuals</code>: Whether to compute Lagrange Multiplier residuals. This will automatically be set to false if a <code>variable</code> parameter is not supplied. Other cases where the user may want to set this to false is when a different geometric algorithm is used for computing residuals for the LM and primal variables. For example, in mechanical contact the Karush-Kuhn-Tucker conditions may be enforced at nodes (through perhaps a <code>NodeFaceConstraint</code>) whereas the contact forces may be applied to the displacement residuals through <code>MortarConstraint</code> </p></li><li><p><code>compute_primal_residuals</code>: Whether to compute residuals for the primal variables. Again this may be a useful parameter to use when applying different geometric algorithms for computing residuals for LM variables and primal variables. </p></li><li><p><code>periodic</code>: Whether this constraint is going to be used to enforce a periodic condition. This has the effect of changing the normals vector, for mortar projection, from outward to inward facing.</p></li></ul><p>At present, either the <code>secondary_variable</code> or <code>primary_variable</code> parameter must be supplied.</p></section><section id="d3f8ecde-c624-4c57-b83e-fea0e68e829b" data-section-level="3" data-section-text="Limitations"><h3 id="limitations">Limitations</h3><p>Unfortunately the mortar system does not currently work in three dimensions. It is on the to-do list, but it will require a significant amount of work to get all the projections correct.</p></section></section><section id="384ef820-d4a1-4218-93a2-44a0dd4d4104" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/constraints/CoupledTiedValueConstraint.html">CoupledTiedValueConstraint</a>Requires the value of a variable to be the consistent on both sides of an interface.</li><li class="collection-item"><a href="../../source/constraints/EqualGradientConstraint.html">EqualGradientConstraint</a>EqualGradientConstraint enforces continuity of a gradient component between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/EqualValueBoundaryConstraint.html">EqualValueBoundaryConstraint</a>Constraint for enforcing that variables on each side of a boundary are equivalent.</li><li class="collection-item"><a href="../../source/constraints/EqualValueConstraint.html">EqualValueConstraint</a>EqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/EqualValueEmbeddedConstraint.html">EqualValueEmbeddedConstraint</a>This is a constraint enforcing overlapping portions of two blocks to have the same variable value</li><li class="collection-item"><a href="../../source/constraints/LinearNodalConstraint.html">LinearNodalConstraint</a>Constrains secondary node to move as a linear combination of primary nodes.</li><li class="collection-item"><a href="../../source/constraints/OldEqualValueConstraint.html">OldEqualValueConstraint</a>OldEqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/TiedValueConstraint.html">TiedValueConstraint</a>Constraint that forces the value of a variable to be the same on both sides of an interface.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="../../source/constraints/NodalFrictionalConstraint.html">NodalFrictionalConstraint</a>Frictional nodal constraint for contact</li><li class="collection-item"><a href="../../source/constraints/NodalStickConstraint.html">NodalStickConstraint</a>Sticky nodal constraint for contact</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="../../source/constraints/GapConductanceConstraint.html">GapConductanceConstraint</a>Computes the residual and Jacobian contributions for the &#x27;Lagrange Multiplier&#x27; implementation of the thermal contact problem. For more information, see the detailed description here: http://tinyurl.com/gmmhbe9</li></ul></section><section id="6e466d51-f90c-4516-b40f-3f1077f5b214" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddConstraintAction.html">AddConstraintAction</a>Add a Constraint object to the simulation.</li></ul></section><section id="19fd80d3-5bc1-44d5-90ce-84dee5ce8d8b" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="osti_1468630">John&nbsp;W. Peterson.
Progress toward a new implementation of the mortar finite element method in moose.
2 2018.
<a href="https://doi.org/10.2172/1468630">doi:10.2172/1468630</a>.<a href="#f6a58697-bab8-4cdb-9944-a06416009fdc" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="f6a58697-bab8-4cdb-9944-a06416009fdc"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{osti_1468630,
    author = "Peterson, John W.",
    title = "Progress toward a new implementation of the mortar finite element method in MOOSE",
    abstractNote = {The mortar finite element method has been used for many years in a variety of applications, including the enforcement of continuity conditions across decomposed domains, the implementation of Dirichlet boundary conditions, obtaining improved estimates of surface fluxes, and for solving large deformation contact mechanics problems. There is a currently great deal of interest in developing more robust mechanical and thermal contact solution strategies in the MOOSE framework and physics modules, and schemes based on the mortar finite element approach appear to be a promising avenue of development. There are a number of challenges associated with the development of a robust Lagrange multiplier based formulation of the mortar finite element method which can be tackled using the relatively simple framework of thermal contact problems, before tackling more complicated applications such as thermomechanical contact. In this report, we describe several aspects of our mortar finite element method implementation for solving thermal contact problems. The approach and notation used are based primarily based on the work of Bin Yang et al. ("Two dimensional mortar contact methods for large deformation frictional sliding," International Journal for Numerical Methods in Engineering 62(9), 2005).},
    doi = "10.2172/1468630",
    journal = "",
    place = "United States",
    year = "2018",
    month = "2"
}
</code></pre></div></div></li></ol></div></section></section></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>